<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: monospace; user-select: none; }
        
        /* UI OVERLAYS */
        #blocker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 999; display: flex; align-items: center; justify-content: center; flex-direction: column; }
        #instructions { color: white; font-size: 30px; text-align: center; cursor: pointer; background: rgba(0,0,0,0.8); padding: 40px; border: 2px solid white; border-radius: 10px; }
        #error-log { color: red; position: absolute; bottom: 10px; left: 10px; z-index: 1000; font-weight: bold; background: rgba(0,0,0,0.8); padding: 5px; display: none; }

        /* HUD */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 16px; height: 16px; background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=='); border: 2px solid rgba(255,255,255,0.8); transform: translate(-50%, -50%); z-index: 10; border-radius: 50%; }
        #coords { position: absolute; top: 10px; left: 10px; color: white; font-weight: bold; text-shadow: 2px 2px 0 #000; z-index: 10; font-size: 18px; }
        
        /* HOTBAR */
        #hotbar-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 5px; z-index: 10; }
        #hotbar { display: flex; gap: 4px; background: rgba(0,0,0,0.6); padding: 6px; border-radius: 5px; }
        .slot { width: 50px; height: 50px; border: 3px solid #555; background: rgba(0,0,0,0.4); color: white; display: flex; align-items: center; justify-content: center; font-size: 24px; position: relative; cursor: pointer; }
        .slot::after { content: attr(data-count); position: absolute; bottom: 2px; right: 2px; font-size: 14px; font-weight: bold; }
        .selected { border-color: white; background: rgba(255,255,255,0.2); transform: scale(1.1); box-shadow: 0 0 10px white; }

        /* CRAFTING MENU */
        #crafting-menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; background: #222; color: white; border: 4px solid #888; padding: 20px; z-index: 500; }
        .recipe-btn { padding: 10px; margin: 5px; background: #444; border: 1px solid #666; cursor: pointer; display: flex; justify-content: space-between; }
        .recipe-btn:hover { background: #555; }
    </style>
    
    <!-- LIBRARIES (CDN) -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        { "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
        }}
    </script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>CLICK TO PLAY</h1>
            <p>WASD to Move | SPACE to Jump</p>
            <p>Left Click: Mine | Right Click: Build</p>
            <p>E: Crafting | Scroll: Hotbar</p>
        </div>
    </div>
    <div id="error-log"></div>

    <div id="coords">Init...</div>
    <div id="crosshair"></div>
    
    <div id="crafting-menu">
        <h2 style="text-align:center; margin-top:0;">CRAFTING</h2>
        <div id="crafting-list"></div>
        <button onclick="document.getElementById('crafting-menu').style.display='none'; document.body.requestPointerLock();" style="width:100%; margin-top:10px; padding:10px; cursor:pointer;">Close</button>
    </div>

    <div id="hotbar-container">
        <div id="hotbar">
            <!-- 9 Slots Generated by JS -->
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { createNoise2D } from 'simplex-noise';

        // ==========================================
        // 1. ERROR HANDLING
        // ==========================================
        window.onerror = function(msg, url, line) {
            const log = document.getElementById('error-log');
            log.style.display = 'block';
            log.innerHTML += `Error: ${msg}<br>`;
            return false;
        };

        // ==========================================
        // 2. TEXTURE GENERATION
        // ==========================================
        function createTexture(color) {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color; ctx.fillRect(0,0,64,64);
            for(let i=0; i<400; i++) {
                ctx.fillStyle = Math.random()>0.5?'rgba(255,255,255,0.1)':'rgba(0,0,0,0.1)';
                ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const MATS = {
            GRASS: new THREE.MeshLambertMaterial({ map: createTexture('#567d46') }),
            DIRT:  new THREE.MeshLambertMaterial({ map: createTexture('#8B4513') }),
            STONE: new THREE.MeshLambertMaterial({ map: createTexture('#757575') }),
            WOOD:  new THREE.MeshLambertMaterial({ map: createTexture('#5C4033') }),
            LEAF:  new THREE.MeshLambertMaterial({ map: createTexture('#228B22') }),
            DIAMOND_ORE: new THREE.MeshLambertMaterial({ map: createTexture('#00FFFF') }),
            BEDROCK: new THREE.MeshLambertMaterial({ map: createTexture('#111') })
        };

        // ==========================================
        // 3. GAME DATA (Items & Recipes)
        // ==========================================
        const ITEMS = {
            WOOD: { id: 1, name: "Wood", icon: "ðŸªµ", placeable: true, mat: 'WOOD' },
            PLANK: { id: 2, name: "Plank", icon: "ðŸŸ«", placeable: true, mat: 'WOOD' },
            STICK: { id: 3, name: "Stick", icon: "ðŸ¥¢", placeable: false },
            STONE: { id: 4, name: "Cobble", icon: "â¬œ", placeable: true, mat: 'STONE' },
            DIRT: { id: 5, name: "Dirt", icon: "ðŸŸ«", placeable: true, mat: 'DIRT' },
            DIAMOND: { id: 6, name: "Diamond", icon: "ðŸ’Ž", placeable: false },
            TABLE: { id: 7, name: "Table", icon: "ðŸªš", placeable: true, mat: 'WOOD' }
        };

        const RECIPES = [
            { name: "Planks (4)", req: { WOOD: 1 }, out: { PLANK: 4 } },
            { name: "Sticks (4)", req: { PLANK: 2 }, out: { STICK: 4 } },
            { name: "Crafting Table", req: { PLANK: 4 }, out: { TABLE: 1 } }
        ];

        // ==========================================
        // 4. INVENTORY SYSTEM
        // ==========================================
        const inventory = {
            slots: new Array(9).fill(null),
            counts: new Array(9).fill(0),
            selected: 0,
            
            init() {
                const hotbar = document.getElementById('hotbar');
                hotbar.innerHTML = '';
                for(let i=0; i<9; i++) {
                    const div = document.createElement('div');
                    div.className = 'slot';
                    div.id = `slot-${i}`;
                    hotbar.appendChild(div);
                }
                this.updateUI();
            },

            addItem(key, count=1) {
                // Stack
                for(let i=0; i<9; i++) if(this.slots[i] === ITEMS[key]) { this.counts[i]+=count; this.updateUI(); return; }
                // New Slot
                for(let i=0; i<9; i++) if(this.slots[i] === null) { this.slots[i] = ITEMS[key]; this.counts[i]=count; this.updateUI(); return; }
            },

            useItem() {
                if(this.slots[this.selected]) {
                    this.counts[this.selected]--;
                    if(this.counts[this.selected] <= 0) this.slots[this.selected] = null;
                    this.updateUI();
                    return true;
                }
                return false;
            },

            updateUI() {
                for(let i=0; i<9; i++) {
                    const el = document.getElementById(`slot-${i}`);
                    if(this.slots[i]) {
                        el.innerText = this.slots[i].icon;
                        el.setAttribute('data-count', this.counts[i]);
                    } else {
                        el.innerText = "";
                        el.setAttribute('data-count', "");
                    }
                    if(i===this.selected) el.classList.add('selected'); else el.classList.remove('selected');
                }
                this.updateCrafting();
            },

            updateCrafting() {
                const list = document.getElementById('crafting-list');
                list.innerHTML = '';
                RECIPES.forEach(r => {
                    const btn = document.createElement('div');
                    btn.className = 'recipe-btn';
                    btn.innerText = r.name;
                    let can = true;
                    for(const [k, q] of Object.entries(r.req)) {
                        if(this.count(k) < q) can = false;
                    }
                    if(can) {
                        btn.style.borderColor = '#0f0';
                        btn.onclick = () => this.craft(r);
                    } else {
                        btn.style.opacity = '0.5';
                    }
                    list.appendChild(btn);
                });
            },

            count(key) {
                let t=0; for(let i=0;i<9;i++) if(this.slots[i]===ITEMS[key]) t+=this.counts[i]; return t;
            },

            craft(r) {
                for(const [k,q] of Object.entries(r.req)) {
                    let rem = q;
                    for(let i=0;i<9;i++) if(this.slots[i]===ITEMS[k]) {
                        const take = Math.min(rem, this.counts[i]);
                        this.counts[i]-=take; rem-=take;
                        if(this.counts[i]<=0) this.slots[i]=null;
                        if(rem===0) break;
                    }
                }
                for(const [k,q] of Object.entries(r.out)) this.addItem(k, q);
            }
        };
        inventory.init();

        // ==========================================
        // 5. WORLD GENERATION
        // ==========================================
        const noise2D = createNoise2D();
        const CHUNK_SIZE = 16;
        const RENDER_DIST = 3;
        const chunks = new Map();
        const geometry = new THREE.BoxGeometry(1, 1, 1);

        function getSurfaceHeight(x, z) {
            const g = noise2D(x/60, z/60);
            const l = noise2D(x/20, z/20);
            return Math.floor(g * 20 + l * 5);
        }

        function getBlockType(x, y, z) {
            const s = getSurfaceHeight(x, z);
            if(y > s) return null;
            if(y === s) return 'GRASS';
            if(y > s-4) return 'DIRT';
            if(y <= -60) return 'BEDROCK';
            const r = Math.abs(noise2D(x/3, y/3+z/3));
            if(y < -15 && r > 0.94) return 'DIAMOND_ORE';
            return 'STONE';
        }

        function updateWorld(scene, px, pz) {
            const cx = Math.floor(px / CHUNK_SIZE);
            const cz = Math.floor(pz / CHUNK_SIZE);

            // Create Chunks
            for(let x=-RENDER_DIST; x<=RENDER_DIST; x++) {
                for(let z=-RENDER_DIST; z<=RENDER_DIST; z++) {
                    const key = `${cx+x},${cz+z}`;
                    if(!chunks.has(key)) createChunk(scene, cx+x, cz+z);
                }
            }
            // Remove Chunks
            for(const [key, grp] of chunks.entries()) {
                const [mx, mz] = key.split(',').map(Number);
                if(Math.abs(mx-cx) > RENDER_DIST+1 || Math.abs(mz-cz) > RENDER_DIST+1) {
                    scene.remove(grp); chunks.delete(key);
                }
            }
        }

        function createChunk(scene, cx, cz) {
            const grp = new THREE.Group();
            const data = {};
            Object.keys(MATS).forEach(k => data[k] = []);

            for(let x=0; x<CHUNK_SIZE; x++) {
                for(let z=0; z<CHUNK_SIZE; z++) {
                    const wx = cx*CHUNK_SIZE+x;
                    const wz = cz*CHUNK_SIZE+z;
                    const s = getSurfaceHeight(wx, wz);
                    const lim = Math.max(-64, s-40); // Deep render

                    for(let y=s; y>=lim; y--) {
                        const t = getBlockType(wx, y, wz);
                        if(t) data[t].push(wx, y, wz);
                    }
                    
                    // Tree (Simple)
                    if(Math.random() > 0.99) {
                        data['WOOD'].push(wx, s+1, wz, wx, s+2, wz, wx, s+3, wz);
                        data['LEAF'].push(wx, s+4, wz, wx+1, s+3, wz, wx-1, s+3, wz, wx, s+3, wz+1, wx, s+3, wz-1);
                    }
                }
            }

            Object.keys(data).forEach(t => {
                const arr = data[t];
                if(arr.length === 0) return;
                const m = new THREE.InstancedMesh(geometry, MATS[t], arr.length/3);
                const o = new THREE.Object3D();
                for(let i=0; i<arr.length/3; i++) {
                    o.position.set(arr[i*3], arr[i*3+1], arr[i*3+2]);
                    o.updateMatrix();
                    m.setMatrixAt(i, o.matrix);
                }
                grp.add(m);
            });
            scene.add(grp);
            chunks.set(`${cx},${cz}`, grp);
        }

        // ==========================================
        // 6. MAIN SETUP
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 100, 50);
        scene.add(sun);

        // --- CONTROLS ---
        const controls = new PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const craftMenu = document.getElementById('crafting-menu');
        let isMenuOpen = false;

        document.getElementById('instructions').addEventListener('click', () => controls.lock());
        
        controls.addEventListener('lock', () => {
            blocker.style.display = 'none';
            craftMenu.style.display = 'none';
            isMenuOpen = false;
        });
        
        controls.addEventListener('unlock', () => {
            if(!isMenuOpen) blocker.style.display = 'flex';
        });

        // --- PLAYER ---
        const startX = 0;
        const startZ = 0;
        const ground = getSurfaceHeight(startX, startZ);
        const player = { pos: new THREE.Vector3(startX, ground + 5, startZ), vel: new THREE.Vector3() };
        camera.position.copy(player.pos);
        updateWorld(scene, player.pos.x, player.pos.z);

        // --- SOCKET ---
        let socket;
        const otherPlayers = {};
        const pMat = new THREE.MeshBasicMaterial({ color: 'red' });
        const pGeo = new THREE.BoxGeometry(0.6, 1.8, 0.6);

        if(typeof io !== 'undefined') {
            socket = io();
            socket.on('currentPlayers', ps => Object.keys(ps).forEach(id => { if(id!==socket.id) addP(id, ps[id]); }));
            socket.on('newPlayer', d => addP(d.id, d.player));
            socket.on('playerMoved', d => { if(otherPlayers[d.id]) otherPlayers[d.id].position.set(d.pos.x, d.pos.y, d.pos.z); });
            socket.on('playerDisconnected', id => { if(otherPlayers[id]) { scene.remove(otherPlayers[id]); delete otherPlayers[id]; }});
        }
        function addP(id, data) {
            const m = new THREE.Mesh(pGeo, pMat);
            m.position.set(data.x, data.y, data.z);
            scene.add(m);
            otherPlayers[id] = m;
        }

        // --- RAYCASTER ---
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0,0);
        
        document.addEventListener('mousedown', e => {
            if(controls.isLocked) {
                raycaster.setFromCamera(center, camera);
                const hits = raycaster.intersectObjects(scene.children, true);
                const hit = hits.find(h => h.distance < 6 && (h.object.isInstancedMesh || h.object.isMesh));
                
                if(hit) {
                    if(e.button === 0 && hit.object.isInstancedMesh) { // Break
                        const m = new THREE.Matrix4();
                        hit.object.getMatrixAt(hit.instanceId, m);
                        m.makeScale(0,0,0);
                        hit.object.setMatrixAt(hit.instanceId, m);
                        hit.object.instanceMatrix.needsUpdate = true;
                        
                        if(hit.object.material === MATS.WOOD) inventory.addItem('WOOD');
                        else if(hit.object.material === MATS.STONE) inventory.addItem('STONE');
                        else inventory.addItem('DIRT');
                    }
                    if(e.button === 2) { // Place
                        const item = inventory.slots[inventory.selected];
                        if(item && item.placeable) {
                            const p = new THREE.Vector3().copy(hit.point).add(hit.face.normal).floor().addScalar(0.5);
                            if(p.distanceTo(player.pos) > 1.5) {
                                const m = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), MATS[item.mat]);
                                m.position.copy(p);
                                scene.add(m);
                                inventory.useItem();
                            }
                        }
                    }
                }
            }
        });

        // --- INPUT ---
        const keys = { w:0, a:0, s:0, d:0, sp:0, sh:0 };
        document.addEventListener('keydown', e => {
            if(e.code==='KeyW') keys.w=1;
            if(e.code==='KeyS') keys.s=1;
            if(e.code==='KeyA') keys.a=1;
            if(e.code==='KeyD') keys.d=1;
            if(e.code==='Space') keys.sp=1;
            if(e.code==='ShiftLeft') keys.sh=1;
            if(e.code==='KeyE') {
                isMenuOpen = !isMenuOpen;
                if(isMenuOpen) { controls.unlock(); craftMenu.style.display='block'; blocker.style.display='none'; }
                else { craftMenu.style.display='none'; controls.lock(); }
            }
        });
        document.addEventListener('keyup', e => {
            if(e.code==='KeyW') keys.w=0;
            if(e.code==='KeyS') keys.s=0;
            if(e.code==='KeyA') keys.a=0;
            if(e.code==='KeyD') keys.d=0;
            if(e.code==='Space') keys.sp=0;
            if(e.code==='ShiftLeft') keys.sh=0;
        });
        document.addEventListener('wheel', e => {
            if(e.deltaY > 0) inventory.selected = (inventory.selected + 1) % 9;
            else inventory.selected = (inventory.selected - 1 + 9) % 9;
            inventory.updateUI();
        });

        // --- LOOP ---
        const clock = new THREE.Clock();
        const elCoords = document.getElementById('coords');
        let emitTimer = 0;

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);

            if(controls.isLocked) {
                const speed = keys.sh ? 10 : 5;
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                fwd.y=0; fwd.normalize();
                const rgt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
                rgt.y=0; rgt.normalize();

                const move = new THREE.Vector3();
                if(keys.w) move.add(fwd);
                if(keys.s) move.sub(fwd);
                if(keys.d) move.add(rgt);
                if(keys.a) move.sub(rgt);
                if(move.length()>0) move.normalize().multiplyScalar(speed*delta);
                player.pos.add(move);

                // PHYSICS (Floor Clamp)
                const floorH = getSurfaceHeight(player.pos.x, player.pos.z);
                player.vel.y -= 30 * delta;
                player.pos.y += player.vel.y * delta;

                if(player.pos.y < floorH + 1.8) {
                    player.pos.y = floorH + 1.8;
                    player.vel.y = 0;
                    if(keys.sp) player.vel.y = 10;
                }
                if(player.pos.y < -100) { player.pos.y = floorH + 20; player.vel.y = 0; }

                camera.position.copy(player.pos);
                elCoords.innerText = `X: ${Math.floor(player.pos.x)} Y: ${Math.floor(player.pos.y)}`;

                if(socket) {
                    emitTimer+=delta;
                    if(emitTimer>0.05) { emitTimer=0; socket.emit('playerMovement', {x:player.pos.x, y:player.pos.y, z:player.pos.z}); }
                }
            }
            updateWorld(scene, player.pos.x, player.pos.z);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
