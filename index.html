<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Perfected</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: monospace; user-select: none; }
        
        /* UI */
        #blocker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 999; display: flex; align-items: center; justify-content: center; }
        #instructions { color: white; font-size: 24px; text-align: center; cursor: pointer; background: rgba(0,0,0,0.8); padding: 30px; border: 2px solid white; border-radius: 8px; }
        
        #hud { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 16px; height: 16px; background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=='); border: 2px solid rgba(255,255,255,0.8); transform: translate(-50%, -50%); border-radius: 50%; }
        
        #hotbar-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 5px; pointer-events: auto; }
        #hotbar { display: flex; gap: 4px; background: rgba(0,0,0,0.6); padding: 6px; border-radius: 5px; }
        .slot { width: 48px; height: 48px; border: 2px solid #555; background: rgba(0,0,0,0.4); color: white; display: flex; align-items: center; justify-content: center; font-size: 24px; position: relative; }
        .slot::after { content: attr(data-count); position: absolute; bottom: 2px; right: 2px; font-size: 12px; font-weight: bold; }
        .selected { border-color: white; background: rgba(255,255,255,0.2); transform: scale(1.1); box-shadow: 0 0 10px white; }

        #coords { position: absolute; top: 10px; left: 10px; color: white; font-weight: bold; text-shadow: 1px 1px 0 #000; }
        
        /* MENUS */
        #crafting-menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; background: #222; color: white; border: 2px solid #888; padding: 20px; z-index: 500; pointer-events: auto; }
        .recipe-btn { padding: 8px; margin: 5px 0; background: #444; border: 1px solid #666; cursor: pointer; display: flex; justify-content: space-between; }
        .recipe-btn:hover { background: #555; }
    </style>
    
    <!-- LIBRARIES -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        { "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
        }}
    </script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>CLICK TO START</h1>
            <p>WASD to Move | SPACE to Jump</p>
            <p>Left Click: Break | Right Click: Place</p>
            <p>E: Inventory | Scroll: Select</p>
        </div>
    </div>

    <div id="hud">
        <div id="coords">Init...</div>
        <div id="crosshair"></div>
    </div>
    
    <div id="crafting-menu">
        <h2 style="text-align:center; margin-top:0;">CRAFTING</h2>
        <div id="crafting-list"></div>
        <button id="close-craft" style="width:100%; margin-top:10px; padding:8px;">Close</button>
    </div>

    <div id="hotbar-container">
        <div id="hotbar"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { createNoise2D } from 'simplex-noise';

        // ==========================================
        // 1. TEXTURES & MATERIALS
        // ==========================================
        function createTexture(color) {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color; ctx.fillRect(0,0,64,64);
            for(let i=0; i<300; i++) {
                ctx.fillStyle = Math.random()>0.5?'rgba(255,255,255,0.15)':'rgba(0,0,0,0.15)';
                ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const MATS = {
            GRASS: new THREE.MeshLambertMaterial({ map: createTexture('#567d46') }),
            DIRT:  new THREE.MeshLambertMaterial({ map: createTexture('#8B4513') }),
            STONE: new THREE.MeshLambertMaterial({ map: createTexture('#757575') }),
            WOOD:  new THREE.MeshLambertMaterial({ map: createTexture('#5C4033') }),
            LEAF:  new THREE.MeshLambertMaterial({ map: createTexture('#228B22') }),
            DIAMOND: new THREE.MeshLambertMaterial({ map: createTexture('#00FFFF') }),
            BEDROCK: new THREE.MeshLambertMaterial({ map: createTexture('#111') })
        };

        // ==========================================
        // 2. WORLD & DATA (The Fix)
        // ==========================================
        const noise2D = createNoise2D();
        const CHUNK_SIZE = 16;
        const RENDER_DIST = 3;
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const chunks = new Map();
        
        // MEMORY: Stores changes (Break/Place)
        // Key: "x,y,z" -> Value: ID (0 = Air, 1+ = Block)
        const worldChanges = new Map();

        function getKey(x, y, z) { return `${x},${y},${z}`; }

        function getBaseHeight(x, z) {
            const g = noise2D(x/60, z/60);
            const l = noise2D(x/20, z/20);
            return Math.floor(g * 20 + l * 5);
        }

        // The "Source of Truth" for Physics
        function getBlockID(x, y, z) {
            const key = getKey(x,y,z);
            if (worldChanges.has(key)) return worldChanges.get(key); // Check memory first

            // If no memory, use procedural generation
            const surface = getBaseHeight(x, z);
            if (y > surface) return 0; // Air
            if (y <= -60) return 99; // Bedrock
            return 1; // Generic Solid (Stone/Dirt/Grass)
        }

        function setBlock(x, y, z, type) {
            const key = getKey(x,y,z);
            worldChanges.set(key, type); // 0 = Air, >0 = Solid
        }

        // ==========================================
        // 3. CHUNK RENDERING
        // ==========================================
        function createChunk(scene, cx, cz) {
            const grp = new THREE.Group();
            const data = {};
            Object.keys(MATS).forEach(k => data[k] = []);

            for(let x=0; x<CHUNK_SIZE; x++) {
                for(let z=0; z<CHUNK_SIZE; z++) {
                    const wx = cx*CHUNK_SIZE+x;
                    const wz = cz*CHUNK_SIZE+z;
                    const h = getBaseHeight(wx, wz);
                    const lim = Math.max(-64, h-30);

                    // Render Terrain
                    for(let y=h; y>=lim; y--) {
                        // Check if block was removed by player
                        if (getBlockID(wx,y,wz) !== 0) {
                            let type = 'STONE';
                            if(y===h) type='GRASS';
                            else if(y>h-4) type='DIRT';
                            
                            // Check ores
                            if(y<-10 && Math.random()>0.98) type='DIAMOND';

                            data[type].push(wx, y, wz);
                        }
                    }
                    
                    // Trees (Only if block wasn't removed)
                    if(getBlockID(wx,h,wz)!==0 && Math.random()>0.99) {
                        data['WOOD'].push(wx,h+1,wz, wx,h+2,wz, wx,h+3,wz);
                        data['LEAF'].push(wx,h+4,wz, wx+1,h+3,wz, wx-1,h+3,wz, wx,h+3,wz+1, wx,h+3,wz-1);
                    }
                }
            }

            Object.keys(data).forEach(t => {
                const arr = data[t];
                if(arr.length===0) return;
                const m = new THREE.InstancedMesh(geometry, MATS[t], arr.length/3);
                const o = new THREE.Object3D();
                for(let i=0; i<arr.length/3; i++) {
                    o.position.set(arr[i*3], arr[i*3+1], arr[i*3+2]);
                    o.updateMatrix();
                    m.setMatrixAt(i, o.matrix);
                }
                grp.add(m);
            });
            scene.add(grp);
            chunks.set(`${cx},${cz}`, grp);
        }

        function updateWorld(scene, px, pz) {
            const cx = Math.floor(px / CHUNK_SIZE);
            const cz = Math.floor(pz / CHUNK_SIZE);
            for(let x=-RENDER_DIST; x<=RENDER_DIST; x++) {
                for(let z=-RENDER_DIST; z<=RENDER_DIST; z++) {
                    const key = `${cx+x},${cz+z}`;
                    if(!chunks.has(key)) createChunk(scene, cx+x, cz+z);
                }
            }
            // Simple cleanup
            for(const [key, grp] of chunks.entries()) {
                const [mx, mz] = key.split(',').map(Number);
                if(Math.abs(mx-cx) > RENDER_DIST+1 || Math.abs(mz-cz) > RENDER_DIST+1) {
                    scene.remove(grp); chunks.delete(key);
                }
            }
        }

        // ==========================================
        // 4. INVENTORY
        // ==========================================
        const ITEMS = {
            WOOD: {id:1, icon:"ðŸªµ", mat:'WOOD'}, 
            PLANK: {id:2, icon:"ðŸŸ«", mat:'WOOD'},
            STONE: {id:3, icon:"â¬œ", mat:'STONE'},
            DIRT: {id:4, icon:"ðŸŸ«", mat:'DIRT'},
            DIAMOND: {id:5, icon:"ðŸ’Ž", mat:'DIAMOND'},
            TABLE: {id:6, icon:"ðŸªš", mat:'WOOD'}
        };
        
        const inventory = {
            slots: new Array(9).fill(null),
            counts: new Array(9).fill(0),
            selected: 0,
            init() {
                const hb = document.getElementById('hotbar');
                hb.innerHTML = '';
                for(let i=0; i<9; i++) {
                    const d = document.createElement('div');
                    d.className='slot'; d.id=`slot-${i}`;
                    hb.appendChild(d);
                }
                this.updateUI();
            },
            addItem(k, c=1) {
                for(let i=0; i<9; i++) if(this.slots[i]===ITEMS[k]) { this.counts[i]+=c; this.updateUI(); return; }
                for(let i=0; i<9; i++) if(this.slots[i]===null) { this.slots[i]=ITEMS[k]; this.counts[i]=c; this.updateUI(); return; }
            },
            use() {
                if(this.slots[this.selected]) {
                    this.counts[this.selected]--;
                    if(this.counts[this.selected]<=0) this.slots[this.selected]=null;
                    this.updateUI();
                    return true;
                }
                return false;
            },
            get() { return this.slots[this.selected]; },
            updateUI() {
                for(let i=0; i<9; i++) {
                    const el = document.getElementById(`slot-${i}`);
                    if(this.slots[i]) {
                        el.innerText = this.slots[i].icon;
                        el.setAttribute('data-count', this.counts[i]);
                    } else {
                        el.innerText = "";
                        el.setAttribute('data-count', "");
                    }
                    if(i===this.selected) el.classList.add('selected'); else el.classList.remove('selected');
                }
            }
        };
        inventory.init();

        // ==========================================
        // 5. MAIN SETUP
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 100, 50);
        scene.add(sun);

        // Controls
        const controls = new PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const craftMenu = document.getElementById('crafting-menu');
        
        // Robust Click Handler
        function lock() { if(craftMenu.style.display!=='block') controls.lock(); }
        document.addEventListener('click', (e) => {
            if(e.target.id === 'close-craft') return; // Don't lock if closing menu
            if(!controls.isLocked && craftMenu.style.display!=='block') controls.lock(); 
        });
        
        controls.addEventListener('lock', () => { blocker.style.display='none'; });
        controls.addEventListener('unlock', () => { if(craftMenu.style.display!=='block') blocker.style.display='flex'; });

        document.getElementById('close-craft').onclick = () => {
            craftMenu.style.display = 'none';
            controls.lock();
        };

        // Player
        const startX = 0; const startZ = 0;
        let ground = getBaseHeight(startX, startZ);
        const player = { pos: new THREE.Vector3(startX, ground+10, startZ), vel: new THREE.Vector3() };
        camera.position.copy(player.pos);
        updateWorld(scene, player.pos.x, player.pos.z);

        // Interaction (Raycaster)
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0,0);
        const placeGeo = new THREE.BoxGeometry(1,1,1);

        document.addEventListener('mousedown', e => {
            if(controls.isLocked) {
                raycaster.setFromCamera(center, camera);
                const hits = raycaster.intersectObjects(scene.children, true);
                const hit = hits.find(h => h.distance < 6 && (h.object.isInstancedMesh || h.object.isMesh));
                
                if(hit) {
                    const bx = Math.floor(hit.point.x - (hit.face.normal.x*0.1));
                    const by = Math.floor(hit.point.y - (hit.face.normal.y*0.1));
                    const bz = Math.floor(hit.point.z - (hit.face.normal.z*0.1));

                    // BREAK
                    if(e.button === 0) {
                        setBlock(bx, by, bz, 0); // Mark as Air in memory
                        
                        // Visual update (Cheap way: Reload chunks nearby. Real way: Modify instance)
                        // For this snippet, we just remove the hit object if it's a placed mesh
                        // If it's instanced, we force a world update (simplest logic for single file)
                        if(hit.object.isMesh) scene.remove(hit.object); 
                        else {
                            // Quick refresh trick: Clear chunks to force rebuild next frame
                            chunks.forEach(g => scene.remove(g));
                            chunks.clear();
                            updateWorld(scene, player.pos.x, player.pos.z);
                        }
                        inventory.addItem('DIRT'); // Simple drop
                    }

                    // PLACE
                    if(e.button === 2) {
                        const item = inventory.get();
                        if(item) {
                            const px = Math.floor(hit.point.x + (hit.face.normal.x*0.1));
                            const py = Math.floor(hit.point.y + (hit.face.normal.y*0.1));
                            const pz = Math.floor(hit.point.z + (hit.face.normal.z*0.1));
                            
                            // Don't place inside player
                            const pDist = Math.sqrt((px+0.5-player.pos.x)**2 + (py+0.5-player.pos.y)**2 + (pz+0.5-player.pos.z)**2);
                            if(pDist > 1.5) {
                                setBlock(px, py, pz, 1); // Mark Solid
                                const m = new THREE.Mesh(placeGeo, MATS[item.mat]);
                                m.position.set(px+0.5, py+0.5, pz+0.5);
                                scene.add(m);
                                inventory.use();
                            }
                        }
                    }
                }
            }
        });

        // Inputs
        const keys = { w:0, a:0, s:0, d:0, sp:0, sh:0 };
        document.addEventListener('keydown', e => {
            if(e.code==='KeyW') keys.w=1;
            if(e.code==='KeyS') keys.s=1;
            if(e.code==='KeyA') keys.a=1;
            if(e.code==='KeyD') keys.d=1;
            if(e.code==='Space') keys.sp=1;
            if(e.code==='ShiftLeft') keys.sh=1;
            if(e.code==='KeyE') {
                if(craftMenu.style.display==='block') { craftMenu.style.display='none'; controls.lock(); }
                else { craftMenu.style.display='block'; controls.unlock(); }
            }
        });
        document.addEventListener('keyup', e => {
            if(e.code==='KeyW') keys.w=0;
            if(e.code==='KeyS') keys.s=0;
            if(e.code==='KeyA') keys.a=0;
            if(e.code==='KeyD') keys.d=0;
            if(e.code==='Space') keys.sp=0;
            if(e.code==='ShiftLeft') keys.sh=0;
        });
        document.addEventListener('wheel', e => {
            if(e.deltaY > 0) inventory.selected = (inventory.selected + 1) % 9;
            else inventory.selected = (inventory.selected - 1 + 9) % 9;
            inventory.updateUI();
        });

        // ==========================================
        // 6. PHYSICS LOOP (The Anti-Fall Fix)
        // ==========================================
        const clock = new THREE.Clock();
        const elCoords = document.getElementById('coords');
        let socket; try { socket = io(); } catch(e){}

        // Check if a block exists in DATA
        function checkSolid(x, y, z) {
            return getBlockID(Math.floor(x), Math.floor(y), Math.floor(z)) !== 0;
        }

        function checkCol(newPos) {
            // Check feet and head
            if(checkSolid(newPos.x, newPos.y, newPos.z)) return true;
            if(checkSolid(newPos.x, newPos.y+1, newPos.z)) return true;
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);

            if(controls.isLocked) {
                const speed = keys.sh ? 10 : 5;
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                fwd.y=0; fwd.normalize();
                const rgt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
                rgt.y=0; rgt.normalize();
                
                const move = new THREE.Vector3();
                if(keys.w) move.add(fwd);
                if(keys.s) move.sub(fwd);
                if(keys.d) move.add(rgt);
                if(keys.a) move.sub(rgt);
                if(move.length()>0) move.normalize().multiplyScalar(speed*delta);

                // Horizontal Collision
                if(!checkCol({x:player.pos.x+move.x, y:player.pos.y, z:player.pos.z})) player.pos.x += move.x;
                if(!checkCol({x:player.pos.x, y:player.pos.y, z:player.pos.z+move.z})) player.pos.z += move.z;

                // Vertical Physics
                player.vel.y -= 25 * delta;
                const nextY = player.pos.y + player.vel.y * delta;
                
                // Check if landing on block
                if(player.vel.y < 0 && checkSolid(player.pos.x, nextY, player.pos.z)) {
                    player.vel.y = 0;
                    player.pos.y = Math.floor(player.pos.y); // Snap to block
                    if(keys.sp) player.vel.y = 9;
                } else {
                    player.pos.y = nextY;
                }

                if(player.pos.y < -100) { player.pos.y=100; player.vel.y=0; }
                
                camera.position.copy(player.pos);
                camera.position.y += 1.6; // Eye height

                elCoords.innerText = `X:${Math.floor(player.pos.x)} Y:${Math.floor(player.pos.y)} Z:${Math.floor(player.pos.z)}`;

                if(socket) socket.emit('playerMovement', {x:player.pos.x, y:player.pos.y, z:player.pos.z, r:camera.rotation.y});
            }
            updateWorld(scene, player.pos.x, player.pos.z);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
